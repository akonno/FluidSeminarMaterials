# PyGame-CEによるインタラクティブ表現入門その3：動きと衝突の基礎とゲームへの応用

```{note}
この回のゴール:
1. 位置・速度・加速度を用いて，ボールの運動をpygame-ceのアニメーションとして実装できる。
2. オイラー法による更新の意味と限界を理解し，加速度が一定の場合のより精度の高い位置の計算式（(x += v , dt + 0.5 a , dt^2)）をプログラムに組み込める。
3. 円と壁・長方形（辺および角）との衝突判定と，速度ベクトルの反射による「跳ね返り」の表現を実装できる。
4. マウス操作などの入力と運動・衝突処理を組み合わせて，テニス風ゲームや障害物くぐりゲームなどの簡単な2Dゲームを自作できる。
```

## ボールが跳ね返るアニメーションの作成

ボール（円）がウィンドウ上を移動し，ウィンドウの端で跳ね返るようなアニメーションを作成しよう．将来は物理シミュレーションに近づけられるよう，位置，速度，加速度を考慮したプログラムにしておく．

```python
import pygame

# 初期化
pygame.init()

# 400ピクセル×400ピクセルのウィンドウをつくる
WIDTH, HEIGHT = 400, 400
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("PyGame-CE Program 2: ball motion")

clock = pygame.time.Clock()
running = True
mouseClicked = False

# 円の半径
r = 10
# 初期位置
x = 100
y = 100
# 初速度
vx = 3
vy = 2
# 加速度
ax = 0
ay = 0
# 時間刻み
dt = 1.0

# メインループ
while running:
    # 1. イベント処理
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False  # ウィンドウ右上の×で終了
        elif event.type == pygame.MOUSEBUTTONUP:
            mouseClicked = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouseClicked = True
        # Sキーでスクショ保存
        elif event.type == pygame.KEYDOWN and event.key == pygame.K_s:
            pygame.image.save(screen, "screenshot.png")
            print(f"Saved screenshot to screenshot.png.")

    # 2. 位置を更新
    x += vx*dt
    y += vy*dt

    # 3. 速度を更新
    vx += ax*dt
    vy += ay*dt

    # 4. 壁にぶつかったら，速度を反転させる
    if x - r < 0 and vx < 0:
        vx = -vx
    elif x + r > WIDTH and vx > 0:
        vx = -vx
    if y - r < 0 and vy < 0:
        vy = -vy
    elif y + r > HEIGHT and vy > 0:
        vy = -vy

    # 5. 背景を塗る
    screen.fill((220, 220, 220))  # R,G,B [0-255]

    # 6. 図形を描く
    # 赤い円を(x, y)の位置に描く．
    pygame.draw.circle(screen, (255, 0, 0), (x, y), r)

    # 7. 画面を更新
    pygame.display.flip()

    # 8. フレームレート制御 (1秒あたり60フレーム程度)
    clock.tick(60)

# 終了処理
pygame.quit()
```

このプログラムを実行すると，ボールに見立てた赤い円が画面上を直線的に動き回り，またウィンドウの周囲では跳ね返る（跳ね返っているように運動の向きを変える）．どうしてそのように動作するのか，今後の改造に向けてプログラムの中身を理解しておこう．

```{figure} ./images/media/screenshot3-1.png
:align: center
:label: fig-ss3-1
ボールが跳ね返るプログラムを実行した例．ただしこの例では画面を完全には消さず，ボールの軌道がだんだん薄くなりながら画面に残るように表示している．ボールが直線的に動いていること，壁（ウィンドウの外枠）で跳ね返っていることが分かる．
```

````{important} ポイント
- **メインループ**に入る前に，円の半径，初期位置，初速度，加速度が定義されている．ただしいまは加速度が$x$方向，$y$方向ともに0なので，速度は壁にぶつからない限り一定のままである．
- 位置と速度は常微分方程式を数値的に解く最も基本的な方法である**オイラー陽解法**で計算されている．すなわち，以下のようにして計算される．
  - $x^{n+1} = x^n + v_x \cdot dt$
  - $y^{n+1} = y^n + v_y \cdot dt$
  - $v_x^{n+1} = v_x^n + a_x \cdot dt$
  - $v_y^{n+1} = v_y^n + a_y \cdot dt$
  - ここでは上付き文字をタイムステップの意味で使っているので注意されたい．$x^n$は$x$の$n$乗ではなく，$n$ステップ目での$x$座標を表す．
  - オイラー陽解法は陽的オイラー法または単にオイラー法と呼ばれることもある．後で述べるがこの方法は精度が良くないので，改善が必要である．
- 壁にぶつかったことを壁からの距離と速度で判定している．たとえば左の壁に衝突した場合には，以下のように判定して速度を反転させる．
  ```python
    if x - r < 0 and vx < 0:
        vx = -vx
  ```
  つまり円の左端の位置が壁の位置よりも左になり（壁にめり込むことに相当），かつ，速度の$x$方向成分が負だったら，速度の$x$方向成分を反転させる．右および上下の壁も同様である．
  - 壁からの距離だけでなく速度も判定に使っているのは，計算上の誤差によりボールが壁にくっつくような動きになるのを抑えるためである．速度の評価をせず位置だけ見て速度を反転させると，一度壁で跳ね返ったあと（速度を反転させたあと）にまだ壁から近かった場合に，もういちど速度を反転させてしまうことがある．速度が壁に向かっているときだけ反転させれば，このような不具合は発生しないので，速度も見るようにする．
  - 壁では速度の符号を入れ替えているだけで，減衰は入れていない（速度の絶対値は変えていない）ので，完全弾性衝突（反発係数$e=1$）に相当する衝突になっている．
````

```{admonition} 演習課題
:class: exercise
1. 速度を変えてみよ．
2. ボールの色を変えてみよ．
```

## 重力の導入と計算精度向上

重力のような効果を入れるため，$y$方向加速度を設定してみよう．

```python
ay = 0.5
```

PyGame-CEでは$y$軸の正は下向きなので，`ay`に正の値を入れると画面上では下向きに加速する．つまり下向きの重力がはたらくことに相当する．（画面はピクセル単位で，物理空間とは単位が異なるため，`ay`に重力加速度の正しい値を与えることはあまり意味が無く，適切なアニメーションになるような値を設定すれば良い．）

このように変えると，ボールが地面で跳ね返るようなアニメーションが表示されることと思う．

ただしアニメーションをずっと表示し続けると，おそらくだんだんとボールの跳ね返る高さが高くなり，ついには天井にぶつかり，その後もだんだん速くなり続けるだろう．上に述べたように完全弾性衝突に当たる計算をしているから，正しく計算されていればずっと同じ高さまで跳ね返り続けるはずである．どうしてだんだん高くなるのだろうか?

```{figure} ./images/media/screenshot3-2.png
:align: center
:label: fig-ss3-2
ボールが跳ね返るプログラムを実行した例・重力あり．地面で跳ね返ったボールが放物線を描いて再び落下する様子や，跳ね返る高さがだんだん高くなる様子が分かる．
```

### 位置の計算精度向上

いまのプログラムでは，位置と速度は常微分方程式を数値的に解く最も基本的な方法であるオイラー陽解法で計算されているが，この解法は精度が良くない．速度は時間刻み`dt`の間にだんだんと変化するはずだが，位置を計算するに際してはそのことを考慮せず，$n$ステップ目での速度をそのまま用いて$n+1$ステップ目での位置を求めているからである．特に今回のように常に下向きに加速している場合は，$y$方向の速度が`dt`の間に相対的に下向きに変化することを無視しているので，どんどん高いほうにずれていく．

これを改善する方法はいろいろ提案されているが，今回は加速度が一定であることを利用して位置の計算を改善しよう．

```python
    x += vx*dt + 0.5*ax*dt*dt
    y += vy*dt + 0.5*ay*dt*dt
```

このように$x$と$y$の計算に速度だけでなく，加速度も考慮する．この方法は加速度が一定の場合には解析解を与える．（高校物理または大学1年次の物理の授業で学んでいる式だと思われる．忘れていたら復習しよう．）

```{figure} ./images/media/screenshot3-3.png
:align: center
:label: fig-ss3-3
ボールが跳ね返るプログラムを実行した例・重力あり，制度改善版．跳ね返る高さがほぼ一定になったことが分かる．
```

## 衝突の判定の拡張・長方形との衝突

壁以外のものとの衝突を導入しよう．たとえば長方形を画面上に描き，それと衝突したら跳ね返るようにする．

長方形は画面の端に平行に置き，その領域は左上の座標$(x_{ul}, y_{ul})$と右下の座標$(x_{lr}, y_{lr})$で表すこととする．はじめは固定座標としよう．
（ul, lrはそれぞれupper left, lower rightの意味）

```python
# 長方形を配置
x_ul = 150  # 左上のx座標
y_ul = 250  # 左上のy座標
x_lr = 300  # 右下のx座標
y_lr = 270  # 右下のy座標
```

そしてメインループの中で，長方形ボール（円）が衝突したら跳ね返るようにしよう．

```python
    # 4b. 長方形にぶつかったら，速度を反転させる．
    # 簡易版
    # 長方形の左辺にぶつかった場合
    if vx > 0 and x + r >= x_ul and x - r < x_ul:
        if y + r >= y_ul and y - r <= y_lr:
            vx = -vx
            x = x_ul - r
    
    # 長方形の右辺にぶつかった場合
    if vx < 0 and x - r <= x_lr and x + r > x_lr:
        if y + r >= y_ul and y - r <= y_lr:
            vx = -vx
            x = x_lr + r
    
    # 長方形の上辺にぶつかった場合
    if vy > 0 and y + r >= y_ul and y - r < y_ul:
        if x + r >= x_ul and x - r <= x_lr:
            vy = -vy
            y = y_ul - r
    
    # 長方形の下辺にぶつかった場合
    if vy < 0 and y - r <= y_lr and y + r > y_lr:
        if x + r >= x_ul and x - r <= x_lr:
            vy = -vy
            y = y_lr + r
```

```{figure} ./images/media/screenshot3-4.png
:align: center
:label: fig-ss3-4
ボールが壁面および配置された長方形と衝突すると跳ね返るプログラムを実行した例・重力あり
```

## マウスの動きに合わせて長方形を動かす

長方形が固定のままだと発展性がないので，マウスの動きに合わせて長方形が動くようにしてみよう．

以前の教材で学んだように，マウスカーソルの位置は`mx, my = pygame.mouse.get_pos()`で得られるので，長方形の位置をそれに合わせて動かす．今回は長方形の高さは固定し，横方向にのみ動かしてみる．

```python
    # マウス位置を取得
    mx, my = pygame.mouse.get_pos()

    # マウスの位置に合わせて長方形の位置を変える
    x_ul = mx - 50
    x_lr = mx + 50
```

```{admonition} 演習課題
:class: exercise
上のコードをプログラムのどこに入れれば良いか? 適切な場所に入れて，マウスの動きに合わせて長方形が動くようにせよ．
```

```{figure} ./images/media/screenshot3-5.png
:align: center
:label: fig-ss3-5
ボールが壁面および配置された長方形と衝突すると跳ね返るプログラムを実行した例・長方形がマウスの動きに合わせて横移動する場合
```

## 発展：衝突判定の改善

現在の衝突のコードは判定が簡略化されており，特に長方形の角にボールが近づいた場合には実際に衝突する前に跳ね返る．また跳ね返る方向は常に衝突した方向の真逆である．これをより現実的な衝突に変更したい．

```{figure} ./images/media/screenshot3-6.png
:align: center
:label: fig-ss3-6
ボールが壁面および配置された長方形と衝突すると跳ね返るプログラムで，ボールが長方形の左上隅に「衝突」している例．実際にはボールと長方形とは接触しておらず，また衝突前と速度が反転していることが分かる．
```

```{admonition} 演習課題
:class: exercise
先ほど作成したプログラムを用い，実際に長方形の角にボールをぶつけてみて，どのように跳ね返るか確認せよ．
```

衝突を改善するにあたり，まずボールの位置によって衝突判定を[](#fig-collision-rectangle)のように8通りに分類する．

```{figure} ./images/collision-rectangle.drawio.png
:align: center
:label: fig-collision-rectangle
ボールと長方形との衝突の場合分け．ボールの中心が長方形まわりのどの位置にあるかによって，衝突判定を8通りに分類する．
```

ボールの中心が①～④のいずれかにある場合の衝突判定と跳ね返りは，以前に示した衝突と同じように扱う．ボールの中心が⑤～⑧のいずれかにある場合は，長方形の角に衝突するものとして取り扱う．

ここでは長方形の角に当たった場合には，角に向かって心向き直衝突しているものと考える．つまり角からボールの中心に向かうベクトルを考えたとき，角の位置にはこのベクトルと垂直な壁があり，これと衝突し跳ね返ると考える．従って速度の角→ボール中心向きの成分を取りだし，それを反転させる．

角→ボール中心に向かうベクトルは，

$$\boldsymbol{n}=(x-x_{c}, y-y_{c})$$

と書ける．ここで$(x_c, y_c)$は角の座標である．

このベクトルの長さが円の半径$r$以下のとき，角と衝突している．以下の式では$n$（太字でない$n$）を$\boldsymbol{n}$（太字の$\boldsymbol{n}$，ベクトルを表す）の大きさの意味で使っている．

$$n^2=(x-x_c)^2+(y-y_c)^2\leq r^2$$

今後の計算のため，法線ベクトル$\boldsymbol{n}$を単位法線ベクトルに変換したものを作る．

$$\hat{\boldsymbol{n}}=\frac{\boldsymbol{n}}{n}$$

現在の速度を$(v_x, v_y)$とすると，法線方向成分はこれと$\hat{\boldsymbol{n}}$との内積で求められる．

$$v_n = \boldsymbol{v}\cdot\hat{\boldsymbol{n}}=v_x\hat{n}_x+v_y\hat{n}_y$$

もし$v_n\geq 0$なら，ボールは角から離れる方向に動いているので，速度は変えなくてよい．$v_n<0$ならボールは角に向かって動いているので，その成分だけ反転させる．

$$\boldsymbol{v}'=\boldsymbol{v}-2v_n\hat{\boldsymbol{n}}$$

これにより角→ボール中心方向成分のみ符号が変わり，接線方向（角→ボール中心方向と垂直な成分）は維持される．

ここで検討した計算方法を，Pythonの関数にしよう．

```python
import math

def collide_circle_corner(x, y, r, vx, vy, x_c, y_c):
    """
    ボール（中心 x, y, 半径 r）と、長方形の角 (x_c, y_c) の衝突を判定し、
    ボールが角に向かっている場合は速度ベクトルを反射させる。

    返り値: (vx_new, vy_new)
    """

    # 角 → ボール中心のベクトル
    dx = x - x_c
    dy = y - y_c

    dist = math.sqrt(dx*dx + dy*dy)

    # 衝突はすでに判定済みとする．（dist <= r のときに呼び出される想定）

    # 単位法線ベクトル（角 → ボール中心）
    nx = dx / dist
    ny = dy / dist

    # 法線方向速度成分 v_n を求める
    v_n = vx * nx + vy * ny  # 法線方向速度成分 v_n

    # v_n < 0 のときだけ「角に向かっている」ので反射させる
    if v_n < 0:
        # 反射: v' = v - 2 (v・n) n
        vx -= 2.0 * v_n * nx
        vy -= 2.0 * v_n * ny

    return vx, vy
```

そして，⑤～⑧の場合はこの関数を使って衝突後の速度を求める．

```python
    # ①左辺にぶつかった場合
    if x < x_ul and y_ul <= y and y <= y_lr and x + r >= x_ul and vx > 0:
        vx = -vx
    # ②右辺にぶつかった場合
    elif x > x_lr and y_ul <= y and y <= y_lr and x - r <= x_lr and vx < 0:
        vx = -vx
    # ③上辺にぶつかった場合
    elif y < y_ul and x_ul <= x and x <= x_lr and y + r >= y_ul and vy > 0:
        vy = -vy
    # ④下辺にぶつかった場合
    elif y > y_lr and x_ul <= x and x <= x_lr and y - r <= y_lr and vy < 0:
        vy = -vy
    # ⑤左上隅にぶつかった場合
    elif x < x_ul and y < y_ul and (x - x_ul)**2 + (y - y_ul)**2 <= r**2:
        vx, vy = collide_circle_corner(x, y, r, vx, vy, x_ul, y_ul)
    # ⑥右上隅にぶつかった場合
    elif x > x_lr and y < y_ul and (x - x_lr)**2 + (y - y_ul)**2 <= r**2:
        vx, vy = collide_circle_corner(x, y, r, vx, vy, x_lr, y_ul)
    # ⑦左下隅にぶつかった場合
    elif x < x_ul and y > y_lr and (x - x_ul)**2 + (y - y_lr)**2 <= r**2:
        vx, vy = collide_circle_corner(x, y, r, vx, vy, x_ul, y_lr)
    # ⑧右下隅にぶつかった場合
    elif x > x_lr and y > y_lr and (x - x_lr)**2 + (y - y_lr)**2 <= r**2:
        vx, vy = collide_circle_corner(x, y, r, vx, vy, x_lr, y_lr)
```

```{figure} ./images/media/screenshot3-7.png
:align: center
:label: fig-ss3-7
ボールと長方形との角の衝突を改善した例．なおボールが角にぶつかりやすいように，ボールの半径を大きくしている．ボールが長方形の右上隅に衝突して速度ベクトルの向きが変わっていることが分かる．
```

```{admonition} 演習課題
:class: exercise
ここまで検討した内容を用いて，長方形の角での衝突を改善せよ．
```

```{admonition} 演習課題（発展）
:class: exercise
[](#fig-ss3-7)では，長方形に少し食い込んでいるように見える．これはなぜか? またプログラムを改変して，ボールが長方形に食い込まないようにせよ．ただし「ボールを小さくする」のと「ボールの動きをゆっくりにする」のは除外し，いまと同様の速度でボールが動きつつ，衝突計算精度を向上させよ．
```

```{admonition} 演習課題（発展）
:class: exercise
長方形をマウスで動かす場合において，長方形を動かす速度が衝突後の反発に影響するようにせよ．端的には衝突時の相対速度を考慮し，それによって衝突後の速度が変わるようにせよ．
```

## 障害物くぐりゲーム（Flappy Bird風）

Flappy Bird風の障害物くぐりゲームを作ろう．ボールを壁や長方形に衝突しないように操作し，衝突したらゲームオーバーとする．

### マウスのクリックに応じて動きを変える

はじめに，ボールが$y$軸方向にのみ動くようにし，またマウスをクリックしている間は上向きに，クリックしていないときは下向きに動くようにしよう．長方形はいったん消す．

```python
    if mouseClicked:
        vy = -2
    else:
        vy = 2
    
    # 2. 位置（yのみ）を更新（加速度は使わない）
    y += vy*dt
```

これで，マウスをクリックしているときは上向き，クリックしていないときは下向きにボールが動くはずである．

### 衝突判定の拡張：複数の長方形と衝突判定

障害物として複数の長方形が画面に現れ，右から左に向かって動くようにしよう．そのためには複数の長方形を扱う必要があるので，「長方形との衝突」を扱う関数を作ろう．

```python

def collision_test(x, y, r, x_ul, y_ul, x_lr, y_lr):
    """円と矩形の衝突判定（詳細版）"""
    # ①左辺にぶつかった場合
    if x < x_ul and y_ul <= y and y <= y_lr and x + r >= x_ul:
        return True
    # ②右辺にぶつかった場合
    elif x > x_lr and y_ul <= y and y <= y_lr and x - r <= x_lr:
        return True
    # ③上辺にぶつかった場合
    elif y < y_ul and x_ul <= x and x <= x_lr and y + r >= y_ul:
        return True
    # ④下辺にぶつかった場合
    elif y > y_lr and x_ul <= x and x <= x_lr and y - r <= y_lr:
        return True
    # ⑤左上隅にぶつかった場合
    elif x < x_ul and y < y_ul and (x - x_ul)**2 + (y - y_ul)**2 <= r**2:
        return True
    # ⑥右上隅にぶつかった場合
    elif x > x_lr and y < y_ul and (x - x_lr)**2 + (y - y_ul)**2 <= r**2:
        return True
    # ⑦左下隅にぶつかった場合
    elif x < x_ul and y > y_lr and (x - x_ul)**2 + (y - y_lr)**2 <= r**2:
        return True
    # ⑧右下隅にぶつかった場合
    elif x > x_lr and y > y_lr and (x - x_lr)**2 + (y - y_lr)**2 <= r**2:
        return True
    return False
```

障害物は上下セットで2つ×5段階程度を配置する．最初は画面の右外に配置し，だんだん画面内に入ってくるようにする．

以下のコードでは障害物で通り抜けられる部分の位置をランダムに決め，それより上とそれより下に障害物となる長方形が置かれるように座標を計算する．そして`obstacles`というリストを用意し，これに障害物となる長方形を格納している．

```python
# 障害物群を作る．
import random
obstacles = []
span_x = 200    # 障害物を置く間隔
x_start = WIDTH + 50
for _ in range(5):
    # 障害物で「空いている部分」の高さを決める．
    hole_y = random.randint(30, HEIGHT - 90)
    obstacles.append( [ x_start, 0, x_start + 50, hole_y] )  # 上の矩形
    obstacles.append( [ x_start, hole_y + 80, x_start + 50, HEIGHT] )  # 下の矩形
    x_start += span_x
```

壁や長方形との衝突を判定する必要がある．衝突したらゲームオーバーにするので，跳ね返りを計算する必要はない．衝突したかどうかを保持する変数`collided`を用意する．

```python
collided = False
```

そしてメインループの中で，壁や障害物（長方形）との衝突を判定する．障害物は複数あるので，`for`ループを使って個々の障害物との衝突を判定する．ここで先ほど作った衝突判定関数`collision_test`が使われている．

```python
    # 4a. 壁にぶつかったら，ゲームオーバー
    if y - r <= 0 and vy < 0:
        collided = True
    elif y + r >= HEIGHT and vy > 0:
        collided = True
    
    # 4b. 矩形にぶつかったら，ゲームオーバー
    for obs in obstacles:
        x_ul, y_ul, x_lr, y_lr = obs
        if collision_test(x, y, r, x_ul, y_ul, x_lr, y_lr):
            collided = True
            break
```

障害物は右から左にゆっくりと動かす．つまり障害物の$x$座標をだんだん小さくする．障害物が左の壁を通過したら，もういちど右側に持って行く．

```python
        # 一番右の障害物の位置を調べる
        max_x = 0
        for o in obstacles:
            if o[0] > max_x:
                max_x = o[0]
        # 長方形を左に向かって少しずつ移動
        for obs in obstacles:
            obs[0] -= 0.5
            obs[2] -= 0.5
            # 画面外に出た障害物は，一番左にある障害物からx_span空けた位置に再配置
            if obs[2] < 0:
                obs[0] = max_x + span_x
                obs[2] = max_x + span_x + 50
```

障害物を画面に表示する機能も，忘れずにつけておく．

```python
    # 6b. 障害物を描く
    for obs in obstacles:
        x_ul, y_ul, x_lr, y_lr = obs
        pygame.draw.rect(screen, (0, 0, 255), (x_ul, y_ul, x_lr - x_ul, y_lr - y_ul))
```

これでFlappy Bird風の障害物くぐりゲームの骨組みができた．


```{figure} ./images/media/screenshot3-8.png
:align: center
:label: fig-ss3-8
障害物くぐりゲームの画面
```

```{admonition} 演習課題
:class: exercise
1. ここまで検討してきた内容に基づき，障害物くぐりゲームを作成せよ．
2. 障害物にぶつかったら，ゲームオーバーになるようにせよ．
3. スコアを表示し，障害物をくぐり抜けたらスコアが加算されるようにせよ．
```

```{admonition} 演習課題（発展）
:class: exercise
1. 現在の障害物くぐりゲームでは，同じ障害物がローテーションして搭乗するが，障害物が画面の左に抜けたら穴の位置を新たに決めて，障害物を作り直すようにせよ．
2. ゲームの難易度がだんだん上がるように，障害物くぐりゲームを改変せよ．
```

## 課題（LMS提出）

以下に課題に取り組み，その成果物のソースコード，および成果物について説明するレポートを提出せよ．
提出方法および提出期限はKU-LMSで確認せよ．

レポートには以下の内容を含めること．
1. 作品の概要（ゲームのルールや目的）
2. 操作方法および実行方法（使用ファイル、実行コマンド）
3. 工夫した点・発展項目（課題2の場合）
4. 実行中のスクリーンショット

```{admonition} 課題1：最小のテニスゲーム（基礎）
:class: assignment
「壁で跳ね返るボールのアニメーション」を改造し、
マウスで動くラケットでボールを打ち返すテニス風ゲームを作成せよ。

必須条件：
- 重力は使わず（ax = ay = 0）、ボールは直線運動とする。
- ラケット（長方形）に当たるとボールが左向きに跳ね返る。
- ボールが左の壁に当たったら 1 点加算する。
- ボールが右の壁に当たったらゲームオーバーとする。
```

```{admonition} 課題2：応用ゲーム（発展）
:class: assignment
課題1を発展させ、オリジナルのゲームまたはインタラクティブ作品を作成せよ。
以下のような例を参考にしてよいが、教材で示したコードをそのまま提出することは不可とする。

例：
- ブロック崩し
- エアホッケー
- インタラクティブアート（軌跡・色・音など）
- 障害物くぐりゲーム（Flappy Bird風）**※ただし必ず以下のいずれかを実装すること**

障害物くぐりゲーム（Flappy Bird風）を選ぶ場合の必須追加条件：以下のいずれかの機能を導入すること．
- 障害物の速度が時間経過で変化する（速くなる／遅くなる）
- 障害物の幅や隙間の大きさが変化する（難易度調整）
- 障害物が上下に動く（往復運動など）
- 背景スクロール、パーティクル、効果音など視覚・聴覚演出を追加
- ゲームオーバー画面、タイトル画面、リトライ機能をつける
- ステージ制（一定スコアで次の難易度へ）を導入
```

## ライセンス

```{note}
このページの本文と図版は CC BY-NC-SA 4.0 とします。  
サンプルコードは MIT License とします。  
一部の学生作品のスクリーンショットなどはこの限りではありません。  
提出物（あなた自身のコードやスクリーンショット）は，ポートフォリオや就職活動で自由に使ってよいものとします。
```
